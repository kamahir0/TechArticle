# 序論
どうも！ AM3・クライアントエンジニアの平塚です。

時に、

皆さんのプロジェクトでは **デバッグ機能** どうされてますでしょうか？<br>
配属2カ月ちょいの新卒エンジニアは他PJの開発事情など当然のように知らないのですが、<br>
AM3ではこれまで**SRDebugger**というアセットでデバッグ機能を管理してきました。

アイテム付与やストーリー解放といったデバッグコマンドへのアクセスを提供する他、コンソールやプロファイラを実機でも確認可能にするなど、とっても便利な代物です。

しかし...やがてSRDebuggerに対して、ある不満がチーム内で浮かび上がってきました。<br>
それは **「デバッグコマンドが増えすぎてすごく見づらい！」** というものです。

![SRDebugger](https://raw.githubusercontent.com/kamahir0/TechArticle/master/UnityDebugSheetStart/IMG_7799.PNG)
ﾐﾁｨ...

ここまで多すぎると目当てのデバッグコマンドを見つけるのも一苦労ですね。
そこで、今回導入することになったのが**UnityDebugSheet**です。

![UnityDebugSheet](https://raw.githubusercontent.com/kamahir0/TechArticle/master/UnityDebugSheetStart/IMG_7800.PNG)

UnityDebugSheetはデバッグコマンドへのアクセスを階層式に格納するシステムを提供します。目当てのコマンドが見つけやすくなるので開発効率アップが期待できます。

今回の記事は、そんなUnityDebugSheetを新卒エンジニアが導入してみた！というお話です。

# 2つの概念
UnityDebugSheetを使う上で知っておくべき「セル」「ページ」という2つの概念があります。簡単にご説明しましょう。

## セル
デバッグシート上に配置される**ボタン**、**スイッチ**、**スライダー**といった各要素です。<br>
ボタンを押すことで何らかの処理を呼び出したり、スイッチやスライダーならbool・floatなどの値をここから取得することも可能です。また、完全オリジナルのセルを作ることもできます。

![cell](https://raw.githubusercontent.com/kamahir0/TechArticle/master/UnityDebugSheetStart/IMG_3791.PNG)

## ページ
セルの集合体であり、デバッグシートの階層の単位であり、常に1つ表示されています。
前項のセルの一種に**ページリンクボタン**というセルが用意されており、これを押すことでページから別のページへと進むことができます。<br>
また、デバッグシートの最も根本の階層部にあたるページは特別に**ルートページ**と呼ばれます。

![page](https://raw.githubusercontent.com/kamahir0/TechArticle/master/UnityDebugSheetStart/IMG_3790.PNG)

# 良い点・微妙な点
## 良い点
### アクセスしやすいデザイン
序論でも述べていますが、お目当ての機能にアクセスしやすいです。<br>
SRDebuggerは精々ボタンをやんわりグループ分けする程度しかできませんでしたが、UnityDebugSheetは階層式なので同じ画面中に並ぶボタンを絞れます。ﾐﾁｨ...なんて擬音とはオサラバです。<br>
またデバッグシートのセルには標準で、アイコンやサブテキストを付加する機能が用意されています。アイコンで分かりやすくできるのは勿論、サブテキストが意外に偉いです。

![SubText](https://raw.githubusercontent.com/kamahir0/TechArticle/master/UnityDebugSheetStart/IMG_7840.PNG)
 > サブテキストのおかげで、ページの中身がそれとなく推測できるようになっている

サブテキストに簡単な説明を併記しておくだけで、初見のデバッグコマンドの機能やページリンクボタンのリンク先ページの特色が、それを使わずとも推測できるようになります。<br>
これは持論ですが... **「それを使うとどうなるか」が使うまでもなく分かる** というのは、使い勝手を大きく左右するファクターだと私は思っています。

### ポップアップいらず
UnityDebugSheetにおいては、各ページクラスの`Initialize`関数の中に`Add〇〇`という関数群の呼び出しを書くことで、ページにセルが配置されるようになります。ここで、このAdd系関数はすべてint型のidを返します。<br>
ページクラスには`GetCell`関数なるものが用意されており、上述のidを使うことでセルの参照を得られる仕組みになっています。<br>
これが非常に強力で、ボタンから実行する処理で動的にセルの状態を変化させることができます。

![増築ページ](https://raw.githubusercontent.com/kamahir0/TechArticle/master/UnityDebugSheetStart/IMG_7842.PNG)
 > 例) 浮島艦増築デバッグコマンド<br>
 >一番上のセルは文字列を表示するだけの機能を持つラベルセルで、その下がインプットフィールドセル。インプットフィールドにIDを入力すると、DBから対応した艦パーツのEntityを引っ張ってきてラベルを更新する仕組み。SRDebugger時代にこのような艦パーツ名を確認できる機能はなかった。

こういった凝ったデバッグ機能は従来であれば、専用ポップアップを作ってSRDebuggerにポップアップ呼び出しボタンを追加するような実装をしていたはずです。<br>
しかしUnityDebugSheetなら、ページクラス範囲内のコーディングだけで同等のものが作れます。AM3にも一応コーディングだけで作れる`DefaultPopup`といったものは存在しますが、自由度ではデバッグシートに軍配が上がるのではないでしょうか。

### スライドで開けるのが結構いい
SRDebuggerは画面の角のいずれかを選んで、そこを３回タップすると開くという仕組みでした。<br>
一方UnityDebugSheetは同じような開き方に加えて、画面両端を縦にスライドすると開くという方式も併用できます。<br>
iPhoneなんかは特に角丸なので、角のボタンはタップしづらかったりしますよね。その点デバッグシートは開きやすいです。（多少は慣れが必要かもしれませんが）

## 微妙な点
### ページリンクボタンがオブジェクト指向的じゃない
先にちょろっと触れた、他のページへリンクする**ページリンクボタン**セルについて。<br>
このボタン、通常のButtonセル同様にボタンテキスト・サブテキスト・アイコンなど設定できるのですが...
なんとそのままの仕様だと、これらの情報は**ページリンクボタンを配置する側が引数に渡してやる**必要があります。これが個人的には気に入らない点ですね。<br>
ページXにリンクするページリンクボタンを作成するなら、そのボタンに表示される文言やアイコンといった情報は**ページXクラスの定義**に置いておきたいところです。

### ピン留め機能がない
SRDebuggerには好きなボタンをピン留めして画面下部に常時表示させる機能がありますが、UnityDebugSheetにはそのような機能はありません。
人によってはあまり使う機会もないかもしれませんね。しかし少なくとも、AM3のインゲームを触るようになってからはこの機能とてもよく使うので、無いとちょっと困ります。

# 導入にあたって行った工夫
前項では色々とデバッグシートの微妙な点も挙げましたが、これらは導入するにあたっての工夫次第でカバーできるなとも思いました。
そこで、私がとったアプローチを紹介したいと思います。
## AddPageLinkButton関数をシンプルに
UnityDebugSheetが用意するページリンクボタンへの不満は先に述べた通りです。
通常はページにページリンクボタンを追加する場合、

`AddPageLinlButton<TPage>(Text, SubText, icon, etc...);`

...のように関数を呼び出す必要があります。しかし、ページリンクボタンの情報くらいリンク先のクラスに持たせたい。<br>
そのために`DebugPageAttribute`というアトリビュートを作ることにしました。<br>
こんな感じです。

```
/// <summary>
/// デバッグページに付けるアトリビュート
/// </summary>
[AttributeUsage(AttributeTargets.Class, Inherited = true)]
public class DebugPageAttribute : Attribute
{
    /// <summary> デバッグページのタイトル </summary>
    public string Title { get; }

    /// <summary> デバッグページのサブテキスト </summary>
    public string SubText { get; }

    public DebugPageAttribute(string title, string subText = null)
    {
        Title = title;
        SubText = subText;
    }
}
```

これを駆使して、ページリンクボタンは

 * ボタンテキスト・サブテキストはアトリビュートから取得
 * アイコンはページクラス名と同名のSpriteを取得

という風にしてみました。<br>
その上で、標準のページクラスを継承してAM3用の共通ベースクラスを作成しました。その名も`AM3DebugPage`。<br>
ここで標準の`AddPageLinkButton`関数を再定義し、

`AddPageLinlButton<TPage>();`

...のように、引数ナシのきわめてシンプルな形で呼び出せるようにしました。
これにより、ページリンクボタンの表示情報はリンク先のページクラス定義に集約させることができたワケです。

## ルートページに触る必要なし
ページの説明で軽く触れてましたが、全ページの階層関係の根本には**ルートページ**というページが存在しています。<br>
通常のページはリンク時にロードされ前の階層に戻ると破棄されます。
しかし一方でルートページは破棄されるタイミングが存在せず、ゲーム再生時にDontDestroyOnLoad&初期化するのが望ましいです。<br>

故にルートページの初期化にはやや特殊なロジックが走っており、他のエンジニアが後から拡張するシチュエーションを想定すればここは触らずに済む方が楽なのではと考えました。<br>

ですので、そうしました。<br>

具体的には、前項の`DebugPageAttribute`を継承した`LinkFromRootAttribute`と、リフレクションを活用しました。<br>
ルートページもページには違いないので、初期化時には`AddPageLinlButton<TPage>`を呼んでページリンクを作るという基本は同じです。ただ、今回**具体的な`TPage`についての呼びだし**は記述していません。<br>
アセンブリを取得し、「`LinkFromRootAttribute`アトリビュートを持った`AM3DebugPage`の派生クラス」をそれぞれ当てはめて`AddPageLinlButton<TPage>`を呼ぶという仕組みを作りました。<br>

また`Root...`アトリビュートはSortOrderというint型のフィールドを持っており、ルートページに並ぶリンクページボタンらはこの値でソートされます。
これにより、ルートページ直下からリンクするページを追加したい場合は、ルートページ周辺のコードをいじる必要なしにページ追加ができます。

なお既に気づいた方もいるでしょうが、この仕組みの代償として、ルートページには基本ページリンクボタン以外のセルを置けなくなっています。<br>
（ただ個人的には、ルートページに自由にセルを置くことを許容すると、SRDebugger同様にカオス化してしまうのではという懸念がありまして。そういう意味では悪い側面ばかりでもないのでは？と思っています）

# 評価
こうした工夫のもとUnityDebugSheetは導入され、1ヶ月以上経ちました。<br>
早くも他のエンジニアの手で新たなページが追加されたりもしまして、せっかくなので私が施した工夫の率直な評価を聞いてみました。

```
・ 追加の際に基盤を意識せずに書けた（のでよく出来てると思う）
・ 共通のベースクラスを用意した点、AddPageLinkButtonのシンプル化、ベースクラスに色々便利メソッドを設けておいた点は良いと思う
・ ページリンクのアイコン周りはもう少し親切でもよかったのでは*1？
・ ページ追加は確かにしやすいものの、ルートページ周りの工夫がカスタマイズ性をかなり犠牲にしている点は気になる。
```
 >*1 アイコンに使用するSpriteは、ページクラス名と同名のファイルをResources.Loadするという仕様になっている。しかしこの仕様がベースクラスを読みに行かないと分からないという点を指摘されている

拡張のしやすさは私の狙い通り、上手くいっているのかなと思いました。ただいくつか指摘点もあり、改善の余地も分かりました。<br>
日々のコードレビューもそうですが、何にせよこういう客観的な目線は大事ですねえ。

# 改善するなら
## アイコンの仕様を見直したい
上でも指摘されている「ページリンクボタンのアイコンはページクラス名と同名のものをロードしている（Spriteは所定のResourcesフォルダに入れておく）」という仕様は、確かに分かりにくいなと思います。<br>
改善するなら、アイコンのためにロードするファイル名はアトリビュートに定義しておく...みたいな感じが自然でしょうか。既にボタンテキストとサブテキストはそうしているワケで、まあこれはある種ケアレスミスと言えるかも。くやしいです。

## ピン留めを実装したい
これ、最初は「実装するならかなり自作しなきゃいけない要素が増えるなぁ」という感じだったのですが......SRDebuggerのコードを読んでて気づいたちゃいました。<br>
実はSRDebuggerのピン留め機能って**外部から呼び出せるよう開かれてる**し、何なら**SRDebugger側のコード上にない処理でもピン留めを動的生成できる**みたいなんですよね。これはびっくり。<br>
なので、デバッグシートが標準で用意しているボタンセルを真似て`AM3ButtonCell`的なのを作って、そこにピン留めボタンを設けるみたいなイメージで作りたいですね。これは手が空き次第やりたいとさえ思います。

# 総括
結論としては、「導入してよかった！」という感想が来ますね。<br>
「階層式」というのは開発ともに増大し続けるデバッグコマンドの管理法としてのアンサーの１つだと思います。<br>

それと、使いにくさを覚えたデバッグシートの本来の仕様を御するための仕組みを考えるのが凄く楽しかったです。配属されてから現場のコードを読んでいって、吸収したことを多少は活かせていたのではないかと思っています。<br>

今回の実装は規模も小さく、またユーザーの目にも触れない、精々「設計ごっこ」程度のものでした。<br>しかし今回のデバッグシート導入業務を経て、いつか自分も新規タイトルの設計に関われるくらいのエンジニアになりたいなァーーーと、そんなことを思いました。<br>
今回の記事は以上です。ご精読ありがとうございました！
